import{_ as d,M as i,p as r,q as l,N as a,R as e,t,a1 as s}from"./framework-bf3e1922.js";const h={},c=s(`<h1 id="file-handling-on-lambda" tabindex="-1"><a class="header-anchor" href="#file-handling-on-lambda" aria-hidden="true">#</a> File Handling on Lambda</h1><p>Often, web applications will allow a user to upload content through a form and process that data, or stream content to an authorized user. Processing uploaded data may be a time-consuming task, depending on what it is.</p><p>Serverless is about working within constraints. When using Lambda and API Gateway together<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>, these quotas constrain our ability to do these things:</p><table><thead><tr><th>Quota</th><th>Limit</th><th>Service</th><th>Impact</th></tr></thead><tbody><tr><td>HTTP request size</td><td>6 MB</td><td>Lambda</td><td>Largest file that can be uploaded is under 6MB when you include base64 encoding, headers, etc.</td></tr><tr><td>HTTP response size</td><td>6 MB</td><td>Lambda</td><td>Cannot send a download that&#39;s more than 6MB.</td></tr><tr><td>Request Timeout</td><td>30 seconds</td><td>API Gateway</td><td>Processing any uploaded data or sending any downloads must be completed in ~28 seconds or else the request is aborted.</td></tr></tbody></table><p>These limits are practically a bit lower than the stated quota. For example, binary data is base64-encoded to include in a JSON event that represents the HTTP request. Headers, cookies, and overhead from encoding the data will eat into the 6MB request payload quota.</p><p>When used correctly, an S3 bucket can work around the payload quotas by having the end-user&#39;s browser send data to and from S3 directly instead of channeling it through the API Gateway &amp; Lambda to your application backend.</p><p>This is also cheaper: the compute time for a Lambda to process a 4MB file upload is more expensive than the bandwidth for somebody to upload a file to S3. It&#39;s a very small amount of money, but in an application serving lots of requests, this can add up to a significant cost.</p><p>The request size quotas are specific to the request &amp; response events, and are <em>not</em> a limit on Lambda&#39;s networking capabilities. Lambdas can write 1TB of data to another service such as S3 as long as it complies with the above quotas.</p><h2 id="understanding-traditional-file-uploads-downloads" tabindex="-1"><a class="header-anchor" href="#understanding-traditional-file-uploads-downloads" aria-hidden="true">#</a> Understanding Traditional File Uploads &amp; Downloads</h2><p>In a traditional application, if a user wishes to upload an avatar image, this can be done with an <code>&lt;input type=&quot;file&quot;&gt;</code> tag inside of a form that POSTs data to the server. The server may then validate the file is a PNG of certain dimensions before storing it.</p><p>The form POST would look something like this, with all the image data included inside the HTTP request:</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">POST</span> <span class="token request-target url">/upload</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">multipart/form-data; boundary=---------------------------9051914041544843365972754266</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">2048</span></span>

<span class="token header"><span class="token header-name keyword">Content-Disposition</span><span class="token punctuation">:</span> <span class="token header-value">form-data; name=&quot;file2&quot;; filename=&quot;a.png&quot;</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">image/png</span></span>

[binary data here]
-----------------------------9051914041544843365972754266--
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),p=e("p",null,[t("If only authorized users should have access to download the avatar image, a request might be made to the application backend. It will verify the user is authorized, and then send the contents of the file with a "),e("code",null,"Content-Type: image/png"),t(" header.")],-1),u=e("h2",{id:"understanding-api-gateway-lambda",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#understanding-api-gateway-lambda","aria-hidden":"true"},"#"),t(" Understanding API Gateway & Lambda")],-1),m=e("p",null,"To help understand the rationale behind the 6MB payload constraint, it helps to understand how AWS serverless products implement the concepts from the previous section.",-1),f=e("sup",{class:"footnote-ref"},[e("a",{href:"#footnote2"},"[2]"),e("a",{class:"footnote-anchor",id:"footnote-ref2"})],-1),b={href:"https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://developer.mozilla.org/en-US/docs/Glossary/Base64#encoded_size_increase",target:"_blank",rel:"noopener noreferrer"},v=s(`<p>The 6MB quota itself likely comes from the need to parse the JSON event quickly. Several megabytes of JSON can be both CPU &amp; memory intensive, and this is designed to work with Lambda runtimes with as little as 128MB of memory.</p><h2 id="using-s3-for-file-storage" tabindex="-1"><a class="header-anchor" href="#using-s3-for-file-storage" aria-hidden="true">#</a> Using S3 for File Storage</h2><p>To work around the constraints, browsers should be uploading data to S3 instead of including it with their HTTP requests to the application, and providing the S3 object key in their form submission.</p><p>However, it&#39;s not a good idea to have an S3 bucket just be open for anybody to upload files -- the application still needs to control who is authorized to upload data. Otherwise, any Random Internet Person could begin flooding our S3 buckets with garbage data and there would be no way to stop it.</p><h3 id="delegating-authorization-to-a-user" tabindex="-1"><a class="header-anchor" href="#delegating-authorization-to-a-user" aria-hidden="true">#</a> Delegating Authorization to a User</h3><p>If the S3 bucket is not public, then it must be private -- which requires credentials in order to upload or download anything. A set of AWS credentials is very valuable and cannot be given out to end-users.</p><p>S3 has a mechanism that allows the application to tightly control authorization <em>without</em> exposing any crdentials: pre-signed URLs.</p><p>These are URLs for specific S3 API calls such as uploading an object called <code>moses-avatar.png</code>, or downloading an object called <code>moses-avatar.png</code>. The URL is generated server-side and contains all the necessary information about what the URL is for, plus a signature to prevent tampering with those settings. This URL is only valid for a short period of time. This way, no AWS credentials need to be exposed -- only a time-limited URL authorizing the bearer to manipulate one object in S3.</p><p>Here is an example URL broken out by parameter allowing somebody to change or download the <code>boots-6d3ce8db-6575-4d8d-b2f1-b92408d6a6f8.png</code> object. The <code>X-Amz-Signature</code> is key to the concept: that is the mechanisms which secure this URL from being tampered with to give somebody unintended access. Change any of the other parameters would change the signature, so when it&#39;s calculated and verified, it would no longer match.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://cap-file-submissions-sbx.s3.us-east-2.amazonaws.com/boots-6d3ce8db-6575-4d8d-b2f1-b92408d6a6f8.png
?x-amz-acl=private
&amp;x-amz-server-side-encryption=aws%3Akms
&amp;x-amz-server-side-encryption-aws-kms-key-id=d4569e7e-902f-4be9-8036-c8d272f75104
&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD
&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256
&amp;X-Amz-Credential=AKIARHUTWT6JCCZWET54%2F20230203%2Fus-east-2%2Fs3%2Faws4_request
&amp;X-Amz-Date=20230203T214103Z
&amp;X-Amz-SignedHeaders=host%3Bx-amz-acl%3Bx-amz-server-side-encryption%3Bx-amz-server-side-encryption-aws-kms-key-id
&amp;X-Amz-Expires=300
&amp;X-Amz-Signature=23efc6fca562c364d40c0a79cac9a0a398acd0639535e5bc58371507b8dcaea3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="time-limit" tabindex="-1"><a class="header-anchor" href="#time-limit" aria-hidden="true">#</a> Time Limit</h3><p>The pre-signed URLs have a time limit on them and should be generated as the user is ready to use them. This limit is defined when the application creates the pre-signed URL, but it should never be longer than five minutes.</p><p>This means that file upload forms should not proactively generate a pre-signed URL when the form HTML is rendered. A user may sit on this page for hours without filling out the form, and it would be a problem if the URL expired before they attempted the file upload.</p><p>For a similar reason, it is inadvisable to put pre-signed URLs into <code>&lt;a href=&quot;...&quot;&gt;</code> tags: the user may not click them before they expire. For embedded media (<code>&lt;img&gt;</code>, <code>&lt;obejct&gt;</code>) that the browser will download as soon as the page renders, it&#39;s fine to use the pre-signed URL directly.</p><h3 id="implementing-uploads" tabindex="-1"><a class="header-anchor" href="#implementing-uploads" aria-hidden="true">#</a> Implementing Uploads</h3><p>Implementing this in a web application requires a bit of dancing. The <code>&lt;input type=&quot;file&quot;&gt;</code> field is no longer enough; instead, some Javascript is required to ask the application for a pre-signed URL when a user is ready to do a file upload. Then, the file needs to be uploaded to S3 immediately using that URL.</p><p>There is an additional step needed in this approach to verify the file was uploaded: when the form is submitted, the browser should include the S3 object key. The application should verify that the data was actually uploaded when it validates the inputs.</p><p>The flow would typically look like:</p>`,18),w=e("p",null,[t("There are frontend libraries to facilitate this. When using our Laravel stack, Livewire has support for uploading files to S3 and does all of this for you. Or, you can implement these steps yourself using "),e("code",null,"fetch()"),t(".")],-1),y=e("h3",{id:"implementing-downloads",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#implementing-downloads","aria-hidden":"true"},"#"),t(" Implementing Downloads")],-1),k=e("p",null,[t("For private data, a pre-signed URL to "),e("code",null,"GET"),t(" an object directly from S3 should be used. Even in cases where the Lambda generates a file that could exceed the response size quota, the Lambda needs to put the file in S3 and then send a pre-signed URL to retrieve it.")],-1),T={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition",target:"_blank",rel:"noopener noreferrer"},S=e("code",null,"Content-Disposition",-1),L=e("p",null,[t("When "),e("em",null,"uploading"),t(" files, the URL usually needs to be sent to the browser so the upload can be handled by Javascript. Downloads are usually more straightforward than the two-step uploads process: click the link, get the file.")],-1),x=e("p",null,[t("The simplest way to implement that is to redirect authorized users directly to S3 from the application. If a user clicks the link for "),e("code",null,"/avatar.png"),t(", the server can check their authorization and then send an HTTP redirect with the pre-signed S3 URL. This works for links, "),e("code",null,'<img src="...">'),t(", or even "),e("code",null,'<object data="...">'),t(" embeds for PDFs.")],-1),A=s('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>Lambda has two separate sets of quotas, depending on if its invoked synchronously or asynchronously. API Gateway will always invoke it synchronously, so this document ignores the asynchronous quotas. <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>FastCGI is a binary protocol that Apache, Nginx, and other webservers can convert HTTP requests into when talking to an application backend. For example, the PHP application server PHP-FPM accepts FastCGI requests. <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li></ol></section>',2);function q(U,_){const n=i("Mermaid"),o=i("ExternalLinkIcon");return r(),l("div",null,[c,a(n,{id:"mermaid-93",code:"eJxtzrEKwjAQxvG9T/G9gFgcMxSUDoJDCw04x/TUYNqLl1Rf3xAEHXrr/f7wRXouNFtqnbmJmSrkOwi/I8mmac50wUDyIlHou0FjuwTPZizs98xyH4J31iTHs4KmKeDqPGE0ySAxgrClGEv3R3PYuvhQGBILId2pZCvsu0nhqHWPXV2jO1UfTXM9jA=="}),p,a(n,{id:"mermaid-97",code:"eJxtjsEKgkAURfd+xf2ALGk5C6MySloUJLR+6lOHcsZmRoO+vkGigrrrew7H8q1nVXAiqTbUBvBbGX23bMI4PnOOE5uBjcB2k2HWass2pIEcmWmn6vH/eXlk2XVXWZCTWgmsSSFFQwPDNYzSY6i0+fUsRtEX602JtBeBtAL1rtFGPricwEfmb9cf6NUusMuyI+ZRhMM+eAJcS0st"}),u,m,e("p",null,[t("Instead of a traditional web server that hands off either the HTTP request or a FastCGI request"),f,t(" to the backend application, the API Gateway receives an HTTP request and converts it "),e("a",b,[t("into JSON"),a(o)]),t(".")]),e("p",null,[t("JSON is a text format, so to represent binary data, it must be base64 encoded to be represented as a string. Encoding the data this way will "),e("a",g,[t("increase its size by at least 33%"),a(o)]),t(". In total, this JSON, which must also include headers and other bits of the request, cannot exceed 6MB.")]),a(n,{id:"mermaid-110",code:"eJwrTi0sTc1LTnXJTEwvSszlUgACp6L88uLUIl07O8cATwX3xJLU8sRKKwV31xAF/eL83FTd0qIcsEIkaaBin8TcpJREK4VqBaXc1JKM/BQlKwUloCYlHZukIjsloCaQANwEiLCenp5CLdgwiHZ0S4GGFZcklpQWA/UaGRhA1aJaDHWvlYJHSEgAWJW/NxcAYXxAcw=="}),v,a(n,{id:"mermaid-163",code:"eJx9kDFvwkAMhXd+hcvClHToFgmitIgulYqaRurqJiaySO7C3SUgfj2+AwFD4Caf/N7zZ1va9aRKWjLWBtsJyMPSaQOFJRO+vogWi3ej91IlMP1ouNxamBVdo7GCFTc0A1aAsNKmnQbTRS2+rOtEj461SiCzYtxI+tqQ5VpRBZeU4ucrGO/kYs7fEshF59vB94oDOjRxp+oR+ZXxkwey18wbjM9bf+e/9znpX5S1x8iPQdcbmsdxPLp43v+37AL/+VAPljwP6MNe6UauM38K7ZmWWnBvKqADW5eOiD2TkOBA1cvkBBi7kBM="}),w,y,k,e("p",null,[t("In the application backend, this is implemented very similarly: check if the user is authorized to access an object, and then call the S3 API to generate a pre-signed URL to download that object. The pre-signed URL may include a "),e("a",T,[S,t(" header"),a(o)]),t(" if the object should be downloaded with a certain filename.")]),L,x,a(n,{id:"mermaid-182",code:"eJyFjsEKgkAQhu8+xeDFk1Z4EzIsow4GkgpdB91kUWdtXZV6+laJCC/N6R/4Zr6/Y4+eUc5CjqXExgA9mCshIeuYnNcp2L6/l2LUyQPzUPO86sAKxUi1wMKCiFNlzvCH0nzQtppDxQV5cDqmsMIBFUqnpXJGfwCNJ64HCS8JsmsEd+3/f/JtdE7TGNz1Bi5iYAXETDZIjFT9hEWpybJ4vLvZQfOyJzeqXrKt4zjGG9QAWMI="}),A])}const P=d(h,[["render",q],["__file","file-handling-on-lambda.html.vue"]]);export{P as default};
